package main

import "fmt"

func main() {

	// 定义一个长度是5, 容量是10的切片
	s1 := make([]int, 5, 10)
	// 对s1扩容赋值给s2, 此时s2长度6, 容量10
	s2 := append(s1, 555)

	fmt.Println(s1, len(s1), cap(s1))
	fmt.Println(s2, len(s2), cap(s2))

	// 若此时更改s1 例如s1[0] = 100, 此时s2会相应改变
	//s1与s2依然存在联系是不希望看到的
	s1[0] = 100
	fmt.Println(s2)

	// 扩容机制
	//a切片长度5, 容量5
	var a = []int{1, 2, 3, 4, 5}
	// 当对a进行扩容时, 容量不足以扩容, 根据扩容机制就会对原切片进行拷贝之后容量变为原切片二倍赋给新切片, 但二倍也不是必然的go也会考虑内存对齐等情况导致偏差
	// 所以此时a2长度为6, 容量为12(考虑了其他情况)
	a2 := append(a, 555)

	fmt.Println(a2, len(a2), cap(a2))
	fmt.Println(len(a), cap(a))

	var b1 = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	b2 := append(b1, 11)
	fmt.Println(b2, len(b2), cap(b2))

	// 每次append操作都会检查slice是否有足够的容量, 如果足够会直接在原始数组上追加元素并返回一个新的slice, 底层数组不变, 这种方式很危险
	// 容量不够时, 创建一个新的容量足够的底层数组, 先将之前数组的元素复制过来, 再将新元素追加, 然后返回新的slice, 底层数组是改变的, 这里是对新数组进行扩容

	// 扩容策略 :如果切片容量小于1024个元素, 扩容会翻倍增加容量, 一旦超过1024, 那么增长因子就变成1.25, 即增加原来的 1 / 4

	// arr [100,20,1,2]
	// s1, s2  [1000,20]
	//第一次 [10,20,1]
	// 第二次 [10,20,1,2]
	// 第三次 s3 [10,20,1,2,3]

	// s2[1000. 20]
	// s3[10,20,1,2,3]
}
